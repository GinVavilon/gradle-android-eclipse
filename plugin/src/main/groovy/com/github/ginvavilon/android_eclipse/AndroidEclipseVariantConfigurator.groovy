/**
 * 
 */
package com.github.ginvavilon.android_eclipse;

import com.android.build.gradle.BaseExtension
import com.android.build.gradle.api.BaseVariant

import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ProjectDependency
import org.gradle.api.tasks.SourceSet
import org.gradle.internal.impldep.org.apache.ivy.tools.analyser.DependencyAnalyser
import org.gradle.plugins.ide.eclipse.model.EclipseModel
import org.gradle.plugins.ide.eclipse.model.SourceFolder

/**
 * @author vbaraznovsky
 *
 */
public class AndroidEclipseVariantConfigurator {
    static final String MANIFEST = 'AndroidManifest.xml'
    static final String RES = 'res'

    static final String SOURCES_GENERATED = 'generated'
    static final String SOURCES_LINKED = 'linked'

    static final String PREFIX_SOURCESETS = 'android_'


    static final String PROJECT_PROPERTY_COMMENTS='# This file is automatically generated by Building Tools.\n'+
    '# Do not modify this file -- YOUR CHANGES WILL BE ERASED!\n'+
    '#\n'+
    '# This file must not be checked in Version Control Systems.\n'+
    '#\n'+
    '# To customize properties used by the Ant build system edit\n'+
    '# "ant.properties", and override values to adapt the script to your\n'+
    '# project structure.\n'+
    '#\n'+
    '# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):\n'+
    '#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt\n'+
    '\n'+
    '# Project target.'

    static final String GEN = 'gen';

    static final String JAVA_OUTPUT = "build/eclipse-classes";

    public EclipseModel eclipse
    public BaseVariant variant
    public BaseExtension androidPlugin
    public def project
    private def prefixSource=""
    private Set<File> projectLibs=new HashSet<>();





    void run() {
        updateProjectProperties()
        AndroidEclipseExtension ext=project.extensions.getByName('androidEclipse')

        def configurations = project.configurations
        def library = androidPlugin in com.android.build.gradle.LibraryExtension;

        def buildDir=project.buildDir;

        def eclipseProject = eclipse.project
        def pathVariant = variant.dirName

        def manifestFile
        if (ext.manifest == null){
            manifestFile = null
        } else if (ext.manifest == AndroidEclipseExtension.GENERATED){
            if (library){
                manifestFile=new File("$buildDir/intermediates/manifests/aapt/$pathVariant/AndroidManifest.xml");
            } else {
                manifestFile=new File("$buildDir/intermediates/manifests/full/$pathVariant/AndroidManifest.xml");
            }
        } else {
            manifestFile = project.file(ext.manifest
                    .replaceAll('%buildDir%',"$buildDir")
                    .replaceAll('%pathVariant%',"$pathVariant")
                    )
            if (manifestFile.directory){
                manifestFile= new File(manifestFile,MANIFEST)
            }

        }

        def resFile
        if (ext.resLink == null){
            resFile = null
        } else if (ext.resLink == AndroidEclipseExtension.GENERATED){
            resFile=new File("$buildDir/intermediates/res/$pathVariant");
        } else {
            resFile = project.file(ext.resLink)
        }

        def rFile=new File("$buildDir/generated/source/r/$pathVariant");
        if (manifestFile!=null){
            eclipseProject.linkedResource(name: MANIFEST, type: '1', location: manifestFile.absolutePath);
        }
        if (resFile!=null){
            eclipseProject.linkedResource(name: RES, type: '2', location: resFile.absolutePath);
        }
        eclipseProject.linkedResource(name: GEN, type: '2', location: rFile.absolutePath);



        final def eclipseClasspathSourceSets = eclipse.classpath.sourceSets
        def linkedSourceSets = getSourceSets(eclipseClasspathSourceSets,SOURCES_LINKED)
        def libs=new HashSet()
        def configLibs=new HashSet()
        def linkedSources=new HashSet()
        linkedSources += "gen";
        def projectAbsolutePath = project.file('.').absolutePath

        variant.sourceSets.each { sourceSet ->
            final def name=sourceSet.name.toString()
            def sourceSetName = PREFIX_SOURCESETS+name
            SourceSet mainSourceSet = getSourceSets(eclipseClasspathSourceSets, sourceSetName)
            sourceSet.javaDirectories.each { dir->
                boolean areRelated = dir.absolutePath.startsWith(projectAbsolutePath);
                if (areRelated){
                    mainSourceSet.getJava().srcDir(dir);
                } else {
                    if (dir.exists()){
                        def path = String.valueOf("src-$name")
                        eclipseProject.linkedResource(name: path, type: '2', location: dir.absolutePath);
                        linkedSources += path;
                    }
                }

            }


        }


        addClasspathConfiguration(variant.compileConfiguration, true)
        addClasspathConfiguration(variant.runtimeConfiguration, true)
        addClasspathConfiguration(configurations.androidEclipse)

        def classpathLibs = project.files(variant.getCompileClasspath(null))
                .filter({ File file->
                   projectLibs.find({ 
                            file.absolutePath.startsWith(it.absolutePath)
                        })==null
                })
        
        project.dependencies{
            libsFromVariant classpathLibs
        }

        eclipse.classpath.plusConfigurations+=[
            configurations.libsFromVariant
        ]
        eclipse.classpath.minusConfigurations+=[
            configurations.excludeByVariant
        ]

        def generatedSourceSets = getSourceSets(eclipseClasspathSourceSets,SOURCES_GENERATED)

        ext.generatedDirs.each { dir ->
            generatedSourceSets.getJava().srcDir(project.file("$dir/$pathVariant"));
        }

        eclipse.classpath {
            file {

                whenMerged {
                    entries.removeAll { entry -> entry.kind == 'src' && linkedSources.contains(entry.path) }
                    for (link in linkedSources) {
                        entries += new SourceFolder(link,null)
                    }

                    entries.each { source ->
                        if (source.kind == 'src' && source.hasProperty('output')) {
                            source.output = JAVA_OUTPUT
                        }
                    }
                }

            }
        }
        new VariantProperty(project, variant).store()

    }

    private addClasspathConfiguration(Configuration config, boolean onlyProjects=false) {

        project.dependencies{
            config.allDependencies.each({ dependency->
                if (dependency in ProjectDependency) {
                    Project dependencyProject = dependency.dependencyProject
                    //dependencyProject.afterEvaluate{
                        def plugins=dependencyProject.plugins
                        if ((dependency.targetConfiguration == null)
                        //&&(plugins.hasPlugin('com.android.library'))
                        ) {
                            ProjectDependency updated= dependency.copy()
                            updated.targetConfiguration='default'
                            libsFromVariant updated
                            //  excludeByVariant dependency
                        } else {
                            libsFromVariant dependency
                        }

                        
                    //}
                    projectLibs += dependencyProject.buildDir
                }else {
                    if (!onlyProjects) {
                        libsFromVariant dependency
                    }
                }
            })
        }
    }

    private SourceSet getSourceSets(def eclipseClasspathSourceSets, def sourceSetName) {
        SourceSet mainSourceSet = eclipseClasspathSourceSets.findByName(sourceSetName);
        if (mainSourceSet==null){
            mainSourceSet = eclipseClasspathSourceSets.create(prefixSource+sourceSetName);
        }
        return mainSourceSet
    }

    private appendCapitalizeSuffix(def prefix, def suffix){
        if (prefix.empty){
            return prefix+suffix
        } else {
            return prefix + suffix.capitalize()
        }
    }

    private updateProjectProperties() {
        Properties props = new Properties()
        File propsFile = new File(project.projectDir,'project.properties')
        if (!propsFile.exists()){
            propsFile.createNewFile()
        }
        props.load(propsFile.newDataInputStream())
        props.setProperty('target', project.android.compileSdkVersion)

        def properiesWriter = new PrintWriter(propsFile.newWriter())

        properiesWriter.println(PROJECT_PROPERTY_COMMENTS)

        props.each { k, v ->
            properiesWriter.print(k)
            properiesWriter.print('=')
            properiesWriter.println(v)
        }
        properiesWriter.flush()
        properiesWriter.close()
    }

    public clean() {
        prefixSource="addedAfterClean"
        eclipse.classpath.sourceSets.clear()
        unlinkResource(RES)
        unlinkResource(GEN)
        unlinkResource(MANIFEST)
    }

    private unlinkResource(String name) {
        eclipse.project.linkedResources.removeIf {it.name==name}
    }
}
