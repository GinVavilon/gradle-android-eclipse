/**
 * 
 */
package com.github.ginvavilon.android_eclipse

import com.android.build.gradle.TestedExtension
import com.android.build.gradle.api.BaseVariant

import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ProjectDependency
import org.gradle.api.file.FileSystemLocationProperty
import org.gradle.api.tasks.SourceSet
import org.gradle.plugins.ide.eclipse.EclipsePlugin
import org.gradle.plugins.ide.eclipse.model.EclipseModel
import org.gradle.plugins.ide.eclipse.model.ProjectDependency as EclipseProjectDependency
import org.gradle.plugins.ide.eclipse.model.SourceFolder

/**
 * @author vbaraznovsky
 *
 */
public class AndroidEclipseVariantConfigurator {
    static final String MANIFEST = 'AndroidManifest.xml'
    static final String RES = 'res'

    static final String SOURCES_GENERATED = 'generated'
    static final String SOURCES_LINKED = 'linked'

    static final String PREFIX_SOURCESETS = 'android_'

    static final String PROJECT_PROPERTY_COMMENTS='# This file is automatically generated by Building Tools.\n'+
    '# Do not modify this file -- YOUR CHANGES WILL BE ERASED!\n'+
    '#\n'+
    '# This file must not be checked in Version Control Systems.\n'+
    '#\n'+
    '# To customize properties used by the Ant build system edit\n'+
    '# "ant.properties", and override values to adapt the script to your\n'+
    '# project structure.\n'+
    '#\n'+
    '# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):\n'+
    '#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt\n'+
    '\n'+
    '# Project target.'

    static final String GEN = 'gen'

    static final String JAVA_OUTPUT = "build/eclipse-classes"

    public EclipseModel eclipse
    public BaseVariant variant
    public TestedExtension androidPlugin
    public Project project
    private def prefixSource=""
    private Set<File> projectLibs=new HashSet<>()
    private Set<Project> dependedProjects = new HashSet<>()
    private Set ignoreDependencies = new HashSet<>()

    void run() {
        AndroidEclipseExtension ext=project.extensions.getByName('androidEclipse')
        if(ext.adtPluginConfigured) {
            updateProjectProperties()
        }

        def configurations = project.configurations
        def library = androidPlugin in com.android.build.gradle.LibraryExtension

        def buildDir=project.buildDir

        def eclipseProject = eclipse.project
        def pathVariant = variant.dirName
        def generatedDirs = ext.generatedDirs

        def manifestFile
        if (ext.manifest == null){
            manifestFile = null
        } else if (ext.manifest == AndroidEclipseExtension.GENERATED){
            if (library){
                manifestFile=new File("$buildDir/intermediates/manifests/aapt/$pathVariant/AndroidManifest.xml")
            } else {
                manifestFile=new File("$buildDir/intermediates/manifests/full/$pathVariant/AndroidManifest.xml")
            }
        } else {
            manifestFile = project.file(ext.manifest
                    .replaceAll('%buildDir%',"$buildDir")
                    .replaceAll('%pathVariant%',"$pathVariant")
                    )
            if (manifestFile.directory){
                manifestFile= new File(manifestFile,MANIFEST)
            }
        }

        def resFile
        if (ext.resLink == null){
            resFile = null
        } else if (ext.resLink == AndroidEclipseExtension.GENERATED){
            if (this.variant.hasProperty('mergeResourcesProvider')) {
                resFile = project.tasks[this.variant.mergeResourcesProvider.name]?.outputDir
            } else {
                resFile = this.variant.mergeResources.outputDir
            }
        } else {
            resFile = project.file(ext.resLink)
        }

        
        def outputSources = variant.getOutputs().collect {
            if (it.hasProperty('processResourcesProvider')) {
                project.tasks[it.processResourcesProvider.name].sourceOutputDir
            } else {
                null
            }
        }.findAll { it != null }

        def rFile 
        if (outputSources.size() > 0) {
            rFile = outputSources[0]
        } else {
            rFile = new File("$buildDir/generated/source/r/$pathVariant")
        }
        
        if (manifestFile!=null){
            eclipseProject.linkedResource(name: MANIFEST, type: '1', location: manifestFile.absolutePath)
        }
        if (resFile instanceof FileSystemLocationProperty){
            resFile = resFile.getAsFile().get()
        }

        if (resFile!=null){
            eclipseProject.linkedResource(name: RES, type: '2', location: resFile.absolutePath)
        }

        if (ext.genR) {
            eclipseProject.linkedResource(name: GEN, type: '2', location: rFile.absolutePath)
            generatedDirs -= "$buildDir/generated/source/r"
            outputSources -= rFile
        }


        ignoreDependencies += configurations.ignoreAndroidEclipse.allDependencies
        final def eclipseClasspathSourceSets = eclipse.classpath.sourceSets
        def libs=new HashSet()
        def configLibs=new HashSet()
        def sourceContainer = new SourceContainer(project, eclipseProject)
        if (ext.genR) {
            sourceContainer.addLinkedSource('gen')
        }

        variant.sourceSets.each { sourceSet ->

            final def name = sourceSet.name.toString()
            def sourceSetName = PREFIX_SOURCESETS+name
            SourceSet mainSourceSet = getSourceSets(eclipseClasspathSourceSets, sourceSetName)
            sourceSet.javaDirectories.each { dir->
                sourceContainer.getProjectPath(dir, name)?.with {
                    mainSourceSet.getJava().srcDir(it)
                }
            }
        }

        addClasspathConfiguration(variant.compileConfiguration, false)
        addClasspathConfiguration(variant.runtimeConfiguration, false)
        addClasspathConfiguration(configurations.androidEclipse)

        def classpathLibs = project.files(variant.getCompileClasspath(null))
                .filter({ File file->
                    projectLibs.find({
                        file.absolutePath.startsWith(it.absolutePath)
                    }) == null
                })

        project.dependencies{
            variantEclipseConfiguration classpathLibs
            variantEclipseConfiguration project.files(androidPlugin.bootClasspath)
        }

        eclipse.classpath.plusConfigurations+=[
            configurations.variantEclipseConfiguration
        ]
        eclipse.classpath.minusConfigurations+=[
            configurations.excludeByVariant,
            configurations.ignoreAndroidEclipse
        ]

        def generatedSourceSets = getSourceSets(eclipseClasspathSourceSets, SOURCES_GENERATED)


        generatedDirs.each { dir ->
            generatedSourceSets.getJava().srcDir(project.file("$dir/$pathVariant"))
        }

        outputSources.each {
            if (it.isDirectory()) {
                generatedSourceSets.getJava().srcDir(it)
            }
        }
        if (ext.junitTest) {
            BaseVariant testVariant = androidPlugin.unitTestVariants.find { it.getTestedVariant() == variant }
            testVariant.sourceSets.each { sourceSet ->

                final def name=sourceSet.name.toString()
                def sourceSetName = PREFIX_SOURCESETS+name
                SourceSet mainSourceSet = getSourceSets(eclipseClasspathSourceSets, sourceSetName)
                sourceSet.javaDirectories.each { dir->
                    sourceContainer.getProjectPath(dir, name)?.with {
                        mainSourceSet.getJava().srcDir(it)
                    }
                }
            }


            addTestConfiguration(testVariant.compileConfiguration)
            addTestConfiguration(testVariant.runtimeConfiguration)

            eclipse.classpath.plusConfigurations+=[
                configurations.testVariantEclipseConfiguration
            ]
        }

        eclipse.classpath {
            file {

                whenMerged {

                    dependedProjects.each { dependedProject ->
                        String path

                        if (dependedProject.plugins.hasPlugin(EclipsePlugin.class)) {
                            path = '/' + dependedProject.eclipse.project.name
                        } else {
                            path = '/'+ dependedProject.name
                        }
                        if (entries.find {it.path == path} == null) {
                            entries += new EclipseProjectDependency(path)
                        }
                    }
                    
                    entries.unique({ a,b -> a.path.compareTo(b.path)})
                    
                    entries.removeAll { entry -> entry.kind == 'src' && sourceContainer.isLink(entry.path) }
                    
                    for (link in sourceContainer.linkedSources) {
                        entries += new SourceFolder(link,null)
                    }

                    entries.each { source ->
                        if (source.kind == 'src'
                        && source.hasProperty('output')
                        && (source.output != null)
                        && !source.output?.startsWith(JAVA_OUTPUT)) {
                            source.output = JAVA_OUTPUT+ "/" + source.output?:""
                        }
                    }
                }
            }
        }
        new VariantProperty(project, variant).store()
    }

    private addClasspathConfiguration(Configuration config, boolean onlyProjects=false) {
        project.dependencies{
            config.allDependencies.each({ dependency->
                if (dependency in ProjectDependency) {
                    Project dependencyProject = dependency.dependencyProject

                    if (!ignoreDependencies.contains(dependency)){
                        dependedProjects.add(dependencyProject)
                    }
                    //dependencyProject.afterEvaluate{
                    def plugins = dependencyProject.plugins
                    if ((dependency.targetConfiguration == null)
                    //&&(plugins.hasPlugin('com.android.library'))
                    ) {
                        ProjectDependency updated= dependency.copy()
                        updated.targetConfiguration='default'
                        variantEclipseConfiguration updated
                        //  excludeByVariant dependency
                    } else {
                        variantEclipseConfiguration dependency
                    }


                    //}
                    projectLibs += dependencyProject.buildDir
                } else {
                    if (!onlyProjects) {
                        variantEclipseConfiguration dependency
                    }
                }
            })
        }
    }

    private addTestConfiguration(Configuration config) {

        project.dependencies {
            def exclude =
                    variant.compileConfiguration.allDependencies +
                    variant.runtimeConfiguration.allDependencies +
                    ignoreDependencies
            (config.allDependencies - exclude).each { dependency->
                testVariantEclipseConfiguration dependency
            }
        }
    }

    private SourceSet getSourceSets(def eclipseClasspathSourceSets, def sourceSetName) {
        SourceSet mainSourceSet = eclipseClasspathSourceSets.findByName(sourceSetName)
        if (mainSourceSet==null){
            mainSourceSet = eclipseClasspathSourceSets.create(prefixSource+sourceSetName)
        }
        return mainSourceSet
    }

    private appendCapitalizeSuffix(def prefix, def suffix){
        if (prefix.empty){
            return prefix+suffix
        } else {
            return prefix + suffix.capitalize()
        }
    }

    private updateProjectProperties() {
        Properties props = new Properties()
        File propsFile = new File(project.projectDir,'project.properties')
        if (!propsFile.exists()){
            propsFile.createNewFile()
        }
        props.load(propsFile.newDataInputStream())
        props.setProperty('target', project.android.compileSdkVersion)

        def properiesWriter = new PrintWriter(propsFile.newWriter())

        properiesWriter.println(PROJECT_PROPERTY_COMMENTS)

        props.each { k, v ->
            properiesWriter.print(k)
            properiesWriter.print('=')
            properiesWriter.println(v)
        }
        properiesWriter.flush()
        properiesWriter.close()
    }

    public clean() {
        prefixSource="addedAfterClean"
        eclipse.classpath.sourceSets.clear()
        unlinkResource(RES)
        unlinkResource(GEN)
        unlinkResource(MANIFEST)
    }

    private unlinkResource(String name) {
        eclipse.project.linkedResources.removeIf {it.name==name}
    }
}
